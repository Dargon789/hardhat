"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chalk_1 = __importDefault(require("chalk"));
const calculate_deployment_status_display_1 = require("../../../src/ui/helpers/calculate-deployment-status-display");
const test_format_1 = require("./test-format");
describe("ui - calculate deployment status display", () => {
    const exampleAddress = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
    const differentAddress = "0x0011223344556677889900112233445566778899";
    const exampleStatusResult = {
        chainId: 1,
        started: [],
        timedOut: [],
        held: [],
        failed: [],
        successful: [],
        contracts: {},
    };
    describe("successful deployment", () => {
        it("should render a sucessful deployment", () => {
            const expectedText = (0, test_format_1.testFormat)(`
        Deployment deployment-01 (chainId: 1) was successful

        ${chalk_1.default.bold("Deployed Addresses")}

        MyModule#Token - 0x1F98431c8aD98523631AE4a59f267346ea31F984
        MyModule#AnotherToken - 0x0011223344556677889900112233445566778899`);
            const statusResult = Object.assign(Object.assign({}, exampleStatusResult), { successful: ["MyModule#Token", "MyModule#AnotherToken"], contracts: {
                    "MyModule#Token": {
                        id: "MyModule#Token",
                        address: exampleAddress,
                        contractName: "Token",
                        sourceName: "contracts/Token.sol",
                        abi: [],
                    },
                    "MyModule#AnotherToken": {
                        id: "MyModule#AnotherToken",
                        address: differentAddress,
                        contractName: "AnotherToken",
                        sourceName: "contracts/AnotherToken.sol",
                        abi: [],
                    },
                } });
            const actualText = (0, calculate_deployment_status_display_1.calculateDeploymentStatusDisplay)("deployment-01", statusResult);
            chai_1.assert.equal(actualText, expectedText);
        });
        it("should render a sucessful deployment with no deploys", () => {
            const expectedText = (0, test_format_1.testFormat)(`
        Deployment deployment-01 (chainId: 1) was successful

        ${chalk_1.default.italic("No contracts were deployed")}`);
            const statusResult = Object.assign(Object.assign({}, exampleStatusResult), { successful: ["MyModule#a_call"], contracts: {} });
            const actualText = (0, calculate_deployment_status_display_1.calculateDeploymentStatusDisplay)("deployment-01", statusResult);
            chai_1.assert.equal(actualText, expectedText);
        });
    });
    describe("failed deployment", () => {
        it("should render an execution failure with multiple of each problem type", () => {
            const expectedText = (0, test_format_1.testFormat)(`
        Deployment deployment-01 (chainId: 1) failed

        Futures timed out with transactions unconfirmed after maximum fee bumps:
         - MyModule:MyContract1
         - MyModule:AnotherContract1

        Futures failed during execution:
         - MyModule:MyContract3: Reverted with reason x
         - MyModule:AnotherContract3: Reverted with reason y

        To learn how to handle these errors: https://hardhat.org/ignition-errors

        Futures where held by the strategy:
         - MyModule:MyContract2: Vote is not complete
         - MyModule:AnotherContract2: Server timed out`);
            const statusResult = {
                chainId: 1,
                started: [],
                timedOut: [
                    { futureId: "MyModule:MyContract1", networkInteractionId: 1 },
                    { futureId: "MyModule:AnotherContract1", networkInteractionId: 3 },
                ],
                held: [
                    {
                        futureId: "MyModule:MyContract2",
                        heldId: 1,
                        reason: "Vote is not complete",
                    },
                    {
                        futureId: "MyModule:AnotherContract2",
                        heldId: 3,
                        reason: "Server timed out",
                    },
                ],
                failed: [
                    {
                        futureId: "MyModule:MyContract3",
                        networkInteractionId: 1,
                        error: "Reverted with reason x",
                    },
                    {
                        futureId: "MyModule:AnotherContract3",
                        networkInteractionId: 3,
                        error: "Reverted with reason y",
                    },
                ],
                successful: ["MyModule#Token", "MyModule#AnotherToken"],
                contracts: {
                    "MyModule#Token": {
                        id: "MyModule#Token",
                        address: exampleAddress,
                        contractName: "Token",
                        sourceName: "contracts/Token.sol",
                        abi: [],
                    },
                    "MyModule#AnotherToken": {
                        id: "MyModule#AnotherToken",
                        address: differentAddress,
                        contractName: "AnotherToken",
                        sourceName: "contracts/AnotherToken.sol",
                        abi: [],
                    },
                },
            };
            const actualText = (0, calculate_deployment_status_display_1.calculateDeploymentStatusDisplay)("deployment-01", statusResult);
            chai_1.assert.equal(actualText, expectedText);
        });
    });
    describe("deployment with started but unfinished futures (e.g. simulation errors)", () => {
        it("should render a sucessful deployment", () => {
            const expectedText = (0, test_format_1.testFormat)(`
        Deployment deployment-01 (chainId: 1) has futures that have started but not completed

         - MyModule#Token
         - MyModule#AnotherToken

        Please rerun your deployment.`);
            const statusResult = Object.assign(Object.assign({}, exampleStatusResult), { started: ["MyModule#Token", "MyModule#AnotherToken"] });
            const actualText = (0, calculate_deployment_status_display_1.calculateDeploymentStatusDisplay)("deployment-01", statusResult);
            chai_1.assert.equal(actualText, expectedText);
        });
    });
});
